<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `dynomite` crate."><meta name="keywords" content="rust, rustlang, rust-lang, dynomite"><title>dynomite - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../dynomite/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate dynomite</p><div class="block version"><p>Version 0.10.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all dynomite's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class="location"></p><script>window.sidebarCurrent = {name: "dynomite", ty: "mod", relpath: "../"};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/dynomite/lib.rs.html#1-1403" title="goto source code">[src]</a></span><span class="in-band">Crate <a class="mod" href="">dynomite</a></span></h1><div class="docblock"><p>Dynomite is the set of high-level interfaces making interacting with <a href="https://aws.amazon.com/dynamodb/">AWS DynamoDB</a> more productive.</p>
<p>ðŸ’¡To learn more about DynamoDB, see <a href="https://www.dynamodbguide.com/">this helpful guide</a>.</p>
<h2 id="data-modeling" class="section-header"><a href="#data-modeling">Data Modeling</a></h2>
<p>Dynomite adapts Rust's native types to
DynamoDB's <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html">core components</a>
to form a coherent interface.</p>
<p>The <a href="trait.Attribute.html">Attribute</a> type
provides conversion interfaces to and from Rust's native scalar types which represent
DynamoDB's notion of &quot;attributes&quot;. The goal of this type is to make representing
AWS typed values feel more natural and ergonomic in Rust. Where a conversion is not available you can implement <code>Attribute</code> for your own
types to leverage higher level functionality.</p>
<p>The <a href="trait.Item.html">Item</a> trait
provides conversion interfaces for complex types which represent
DynamoDB's notion of &quot;items&quot;.</p>
<p>ðŸ’¡ A cargo feature named <code>&quot;derive&quot;</code> makes it easy to derive <code>Item</code> instances for your custom types. This feature is enabled by default.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
 <span class="kw">use</span> <span class="ident">dynomite</span>::{<span class="ident">Item</span>, <span class="ident">Attributes</span>};
 <span class="kw">use</span> <span class="ident">uuid</span>::<span class="ident">Uuid</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Item</span>)]</span>
<span class="kw">struct</span> <span class="ident">Order</span> {
  <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">partition_key</span>)]</span>
  <span class="ident">user</span>: <span class="ident">Uuid</span>,
  <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">sort_key</span>)]</span>
  <span class="ident">order_id</span>: <span class="ident">Uuid</span>,
  <span class="ident">color</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
}</pre></div>
<h2 id="attributes" class="section-header"><a href="#attributes">Attributes</a></h2><h3 id="deriveitem" class="section-header"><a href="#deriveitem"><code>#[derive(Item)]</code></a></h3>
<p>Used to define a top-level DynamoDB item.
Generates a <code>&lt;ItemName&gt;Key</code> struct with only <code>partition_key/sort_key</code>
fields to be used for type-safe primary key construction.
This automatically derives <a href="#deriveattributes"><code>Attributes</code></a> too.</p>
<p>For the <code>Order</code> struct from the example higher this will generate an <code>OrderKey</code>
struct like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="kw">struct</span> <span class="ident">OrderKey</span> {
    <span class="ident">user</span>: <span class="ident">Uuid</span>,
    <span class="ident">order_id</span>: <span class="ident">Uuid</span>,
}</pre></div>
<p>Use it to safely and conveniently construct the primary key:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">dynomite</span>::{
    <span class="ident">dynamodb</span>::{<span class="ident">DynamoDb</span>, <span class="ident">GetItemInput</span>},
    <span class="ident">Attributes</span>, <span class="ident">FromAttributes</span>,
};
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">convert</span>::<span class="ident">TryFrom</span>, <span class="ident">error</span>::<span class="ident">Error</span>};
<span class="kw">use</span> <span class="ident">uuid</span>::<span class="ident">Uuid</span>;

<span class="ident">async</span> <span class="kw">fn</span> <span class="ident">get_order</span>(
    <span class="ident">client</span>: <span class="kw">impl</span> <span class="ident">DynamoDb</span>,
    <span class="ident">user</span>: <span class="ident">Uuid</span>,
    <span class="ident">order_id</span>: <span class="ident">Uuid</span>,
) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Order</span><span class="op">&gt;</span>, <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="comment">// Use the generated `OrderKey` struct to create a primary key</span>
    <span class="kw">let</span> <span class="ident">key</span> <span class="op">=</span> <span class="ident">OrderKey</span> { <span class="ident">user</span>, <span class="ident">order_id</span> };
    <span class="comment">// Convert stronly-typed `OrderKey` to a map of `rusoto_dynamodb::AttributeValue`</span>
    <span class="kw">let</span> <span class="ident">key</span>: <span class="ident">Attributes</span> <span class="op">=</span> <span class="ident">key</span>.<span class="ident">into</span>();

    <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">client</span>
        .<span class="ident">get_item</span>(<span class="ident">GetItemInput</span> {
            <span class="ident">table_name</span>: <span class="string">&quot;orders&quot;</span>.<span class="ident">into</span>(),
            <span class="ident">key</span>,
            ..<span class="ident">Default</span>::<span class="ident">default</span>()
        })
        .<span class="ident">await</span><span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(<span class="ident">result</span>
        .<span class="ident">item</span>
        .<span class="ident">map</span>(<span class="op">|</span><span class="ident">item</span><span class="op">|</span> <span class="ident">Order</span>::<span class="ident">try_from</span>(<span class="ident">item</span>).<span class="ident">expect</span>(<span class="string">&quot;Invalid order, db corruption?&quot;</span>)))
}</pre></div>
<ul>
<li>
<p><code>#[dynomite(partition_key)]</code> - required attribute, expected to be applied the target
<a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey">partition attribute</a> field with a derivable DynamoDB attribute value
of String, Number or Binary</p>
</li>
<li>
<p><code>#[dynomite(sort_key)]</code> - optional attribute, may be applied to one target
<a href="sort-key">sort attribute</a> field with an derivable DynamoDB attribute value
of String, Number or Binary</p>
</li>
<li>
<p>All other attributes are the same as for <a href="#deriveattributes"><code>#[derive(Attributes)]</code></a></p>
</li>
</ul>
<h3 id="deriveattributes" class="section-header"><a href="#deriveattributes"><code>#[derive(Attributes)]</code></a></h3>
<p>Used to derive an implementation of <code>From/IntoAttributes</code> trait to allow for
serializing/deserializing map-like types into <a href="https://docs.rs/rusoto_dynamodb/*/rusoto_dynamodb/struct.AttributeValue.html"><code>AttributeValue</code></a>.
This also generates <code>TryFrom&lt;Attributes&gt;</code> and <code>Into&lt;Attributes&gt;</code> implementations.</p>
<ul>
<li>
<p><code>#[dynomite(rename = &quot;actualName&quot;)]</code> - optional attribute, may be applied to any item
attribute field, useful when the DynamoDB table you're interfacing with has
attributes whose names don't following Rust's naming conventions</p>
</li>
<li>
<p><code>#[dynomite(default)]</code> - use <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html#tymethod.default"><code>Default::default</code></a> implementation of the field type
if the attribute is absent when deserializing from <code>Attributes</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">dynomite</span>::<span class="ident">Attributes</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="kw">struct</span> <span class="ident">Todos</span> {
    <span class="comment">// use Default value of the field if it is absent in DynamoDb (empty vector)</span>
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">default</span>)]</span>
    <span class="ident">items</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
    <span class="ident">list_name</span>: <span class="ident">String</span>,
}</pre></div>
</li>
<li>
<p><code>#[dynomite(flatten)]</code> - flattens the fields of other struct that also derives <code>Attributes</code>
into the current struct.</p>
<p>ðŸ’¡ If this attribute is placed onto a field, no other <code>dynomite</code> attributes
are alowed on this field (this restriction may be relaxed in future).</p>
<p>This is reminiscent of <a href="serde-flatten"><code>#[serde(flatten)]</code></a>. The order of
declaration of <code>flatten</code>ed fields matters, if the struct has to fields with
<code>#[dynomite(flatten)]</code> attribute the one that appears higher in code will
be evaluated before the other one. This is crucial when you want to collect
additional properties into a map:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">dynomite</span>::{<span class="ident">Attributes</span>, <span class="ident">Item</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Item</span>)]</span>
<span class="kw">struct</span> <span class="ident">ShoppingCart</span> {
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">partition_key</span>)]</span>
    <span class="ident">id</span>: <span class="ident">String</span>,
    <span class="comment">// A separate struct to store data without any id</span>
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">flatten</span>)]</span>
    <span class="ident">data</span>: <span class="ident">ShoppingCartData</span>,
    <span class="comment">// Collect all other additional attributes into a map</span>
    <span class="comment">// Beware that the order of declaration will affect the order of</span>
    <span class="comment">// evaluation, so this &quot;wildcard&quot; flatten clause should be the last member</span>
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">flatten</span>)]</span>
    <span class="ident">remaining_props</span>: <span class="ident">Attributes</span>,
}

<span class="comment">// `Attributes` doesn&#39;t require neither of #[dynomite(partition_key/sort_key)]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="kw">struct</span> <span class="ident">ShoppingCartData</span> {
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">total_price</span>: <span class="ident">u32</span>,
}</pre></div>
</li>
</ul>
<h4 id="fat-enums" class="section-header"><a href="#fat-enums">Fat enums</a></h4>
<p>Fat enums are naturally supported by <code>#[derive(Attribute)]</code>.
As for now, there is a limitation that the members of the enum must be
either unit or one-element tuple variants. This restriction will be relaxed
in future versions of <code>dynomite</code>.</p>
<p>Deriving <code>Attributes</code> on fat enums currently uses
<a href="https://serde.rs/enum-representations.html#internally-tagged">internally tagged enum pattern</a> (inspired by serde).
Thus, you have to explicitly specify the <strong>field name</strong> of enum tag
via the <code>tag</code> attribute on an enum.</p>
<p>For example, the following definition:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">dynomite</span>::<span class="ident">Attributes</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="comment">// Name of the field where to store the discriminant in DynamoDB</span>
<span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">tag</span> <span class="op">=</span> <span class="string">&quot;kind&quot;</span>)]</span>
<span class="kw">enum</span> <span class="ident">Shape</span> {
    <span class="ident">Rectangle</span>(<span class="ident">Rectangle</span>),
    <span class="comment">// Use `rename` to change the **value** of the tag for a particular variant</span>
    <span class="comment">// by default the tag for a particular variant is the name of the variant verbatim</span>
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;my_circle&quot;</span>)]</span>
    <span class="ident">Circle</span>(<span class="ident">Circle</span>),
    <span class="ident">Unknown</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="kw">struct</span> <span class="ident">Circle</span> {
    <span class="ident">radius</span>: <span class="ident">u32</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attributes</span>)]</span>
<span class="kw">struct</span> <span class="ident">Rectangle</span> {
    <span class="ident">width</span>: <span class="ident">u32</span>,
    <span class="ident">height</span>: <span class="ident">u32</span>,
}</pre></div>
<p>corresponds to the following representation in DynamoDB for each enum variant:</p>
<ul>
<li><code>Rectangle</code>:
<pre><code class="language-json">{
    &quot;kind&quot;: &quot;Rectangle&quot;,
    &quot;width&quot;: 42,
    &quot;height&quot;: 64
}
</code></pre>
</li>
<li><code>Circle</code>:
<pre><code class="language-json">{
    &quot;kind&quot;: &quot;my_circle&quot;,
    &quot;radius&quot;: 54
}
</code></pre>
</li>
<li><code>Unknown</code>:
<pre><code class="language-json">{
    &quot;kind&quot;: &quot;Unknown&quot;
}
</code></pre>
</li>
</ul>
<p>If you have a plain old enum (without any data fields), you should use
<a href="#deriveattribute"><code>#[derive(Attribute)]</code></a> instead.</p>
<h3 id="deriveattribute" class="section-header"><a href="#deriveattribute"><code>#[derive(Attribute)]</code></a></h3>
<p>Derives an implementation of <a href="trait.Attribute.html"><code>Attribute</code></a> for the plain enum.
If you want to use a fat enum see <a href="#fat-enums">this paragraph</a> instead.</p>
<p>The enum istelf will be represented as a string with the name of the variant
it represents.
In contrast, having <a href="deriveattributes"><code>#[derive(Attributes)]</code></a> on an enum
makes it to be represented as an object with a tag field,
which implies an additional layer of indirection.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">dynomite</span>::{<span class="ident">Attribute</span>, <span class="ident">Item</span>};

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Attribute</span>)]</span>
<span class="kw">enum</span> <span class="ident">UserRole</span> {
    <span class="ident">Admin</span>,
    <span class="ident">Moderator</span>,
    <span class="ident">Regular</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Item</span>)]</span>
<span class="kw">struct</span> <span class="ident">User</span> {
    <span class="attribute">#[<span class="ident">dynomite</span>(<span class="ident">partition_key</span>)]</span>
    <span class="ident">id</span>: <span class="ident">String</span>,
    <span class="ident">role</span>: <span class="ident">UserRole</span>,
}</pre></div>
<p>This data model will have the following representation in DynamoDB:</p>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;d97de525-c81d-46d4-b945-d01b3a0f9165&quot;,
    &quot;role&quot;: &quot;Admin&quot;
}
</code></pre>
<p><code>role</code> field here may be any of <code>Admin</code>, <code>Moderator</code>, or <code>Regular</code> strings.</p>
<h2 id="rusoto-extensions" class="section-header"><a href="#rusoto-extensions">Rusoto extensions</a></h2>
<p>By importing the <a href="trait.DynamoDbExt.html">dynomite::DynamoDbExt</a> trait, dynomite
adds client interfaces for creating async Stream-based auto pagination interfaces.</p>
<h2 id="robust-retries" class="section-header"><a href="#robust-retries">Robust retries</a></h2>
<p>By importing the <a href="retry/trait.Retries.html">dynomite::Retries</a> trait, dynomite
provides an interface for adding configuration retry policies so your
rusoto DynamoDb clients.</p>
<h1 id="errors" class="section-header"><a href="#errors">Errors</a></h1>
<p>Some operations which require coercion from AWS to Rust types may fail which results in an
<a href="error/enum.AttributeError.html">AttributeError</a>.</p>
<h1 id="cargo-features" class="section-header"><a href="#cargo-features">Cargo Features</a></h1>
<p>This crate has a few cargo features of note.</p>
<h2 id="uuid" class="section-header"><a href="#uuid">uuid</a></h2>
<p>Enabled by default, the <code>uuid</code> feature adds support for implementing <code>Attribute</code> for
the <a href="https://crates.io/crates/uuid">uuid</a> crate's type <code>Uuid</code>, a useful
type for producing and representing
unique identifiers for items that satisfy <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html">effective characteristics for partition keys</a></p>
<h2 id="chrono" class="section-header"><a href="#chrono">chrono</a></h2>
<p>Enabled by default, the <code>chrono</code> feature adds an implementation of <code>Attribute</code> for
the std's <a href="https://doc.rust-lang.org/std/time/struct.SystemTime.html">SystemTime</a> and chrono <a href="https://docs.rs/chrono/0.4.11/chrono/struct.DateTime.html"><code>DateTime</code></a> types which
internally use <a href="https://www.ietf.org/rfc/rfc3339.txt">rfc3339 timestamps</a>.</p>
<h2 id="derive" class="section-header"><a href="#derive">derive</a></h2>
<p>Enabled by default, the <code>derive</code> feature enables the use of the dynomite derive feature which
allows you to simply add <code>#[derive(Item)]</code> to your structs.</p>
<h2 id="rustls" class="section-header"><a href="#rustls">rustls</a></h2>
<p>Disabled by default, the <code>rustls</code> feature overrides Rusoto's default tls
dependency on OpenSSL, replacing it with a <a href="https://crates.io/crates/rustls"><code>rustls</code></a> based tls implementation. When you
enable this feature. It will also enable <code>uuid</code> and <code>derive</code> by default.</p>
<p>To disable any of these features</p>
<pre><code class="language-toml">[dependencies.dynomite]
version = &quot;xxx&quot;
default-features = false
features = [&quot;feature-you-want&quot;]
</code></pre>
</div><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use rusoto_dynamodb as dynamodb;</code></td></tr><tr><td><code>pub use crate::retry::<a class="trait" href="../dynomite/retry/trait.Retries.html" title="trait dynomite::retry::Retries">Retries</a>;</code></td></tr><tr><td><code>pub use crate::error::<a class="enum" href="../dynomite/error/enum.AttributeError.html" title="enum dynomite::error::AttributeError">AttributeError</a>;</code></td></tr></table><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<table><tr class="module-item"><td><a class="mod" href="error/index.html" title="dynomite::error mod">error</a></td><td class="docblock-short"><p>Dynomite error types</p>
</td></tr><tr class="module-item"><td><a class="mod" href="retry/index.html" title="dynomite::retry mod">retry</a></td><td class="docblock-short"><p>Retry functionality</p>
</td></tr></table><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<table><tr class="module-item"><td><a class="macro" href="macro.attr_map.html" title="dynomite::attr_map macro">attr_map</a></td><td class="docblock-short"><p>Creates a <code>HashMap&lt;String, AttributeValue&gt;</code> from a list of key-value pairs</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.Attribute.html" title="dynomite::Attribute trait">Attribute</a></td><td class="docblock-short"><p>A type capable of being converted into an or from and AWS <code>AttributeValue</code></p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.DynamoDbExt.html" title="dynomite::DynamoDbExt trait">DynamoDbExt</a></td><td class="docblock-short"><p>Extension methods for DynamoDb client types</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.FromAttributes.html" title="dynomite::FromAttributes trait">FromAttributes</a></td><td class="docblock-short"><p>A type capable of being produced from a set of string keys and <a href="https://docs.rs/rusoto_dynamodb/*/rusoto_dynamodb/struct.AttributeValue.html"><code>AttributeValue</code></a>s.
Generally, you should not implement this trait manually.
Use <code>#[derive(Attributes/Item)]</code> to generate the proper implementation instead.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.IntoAttributes.html" title="dynomite::IntoAttributes trait">IntoAttributes</a></td><td class="docblock-short"><p>A type capable of being serialized into a set of string keys and <a href="https://docs.rs/rusoto_dynamodb/*/rusoto_dynamodb/struct.AttributeValue.html"><code>AttributeValue</code></a>s
Generally, you should not implement this trait manually.
Use <code>#[derive(Attributes/Item)]</code> to generate the proper implementation instead.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.Item.html" title="dynomite::Item trait">Item</a></td><td class="docblock-short"><p>A type which can be converted to and from a set of String keys and
<code>AttributeValues</code>.</p>
</td></tr></table><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<table><tr class="module-item"><td><a class="type" href="type.Attributes.html" title="dynomite::Attributes type">Attributes</a></td><td class="docblock-short"><p>Type alias for map of named attribute values</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "dynomite";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>